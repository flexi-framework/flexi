!=================================================================================================================================
! Copyright (c) 2010-2024  Prof. Claus-Dieter Munz
! This file is part of FLEXI, a high-order accurate framework for numerically solving PDEs with discontinuous Galerkin methods.
! For more information see https://www.flexi-project.org and https://nrg.iag.uni-stuttgart.de/
!
! FLEXI is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License
! as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!
! FLEXI is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
! of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License v3.0 for more details.
!
! You should have received a copy of the GNU General Public License along with FLEXI. If not, see <http://www.gnu.org/licenses/>.
!=================================================================================================================================
#include "flexi.h"

!===================================================================================================================================
!> Tool which takes a HDF5 file (no matter what kind) that belongs to a 2D mesh and extends the file so it can be used with a
!> mesh generated by extruding that mesh. It will take any arrays of size nVar*nElems or nVar*N*N*1*nElems, and both the 2D as
!> well as the extruded 3D mesh must be ijk sorted!
!>
!> Usage: posti_to3D 2D_mesh.h5 extruded3D_mesh.h5 fileToExtrude.h5
!===================================================================================================================================
PROGRAM to3D
! MODULES
USE MOD_Globals
USE MOD_Commandline_Arguments
USE MOD_IO_HDF5
USE MOD_HDF5_Input,              ONLY: ReadArray,GetDataSize
USE MOD_HDF5_Output,             ONLY: WriteArray
USE MOD_MPI,                     ONLY: InitMPI
#if USE_MPI
USE MOD_MPI,                     ONLY: FinalizeMPI
#endif
! IMPLICIT VARIABLE HANDLING
IMPLICIT NONE
!-----------------------------------------------------------------------------------------------------------------------------------
! LOCAL VARIABLES
CHARACTER(LEN=255),ALLOCATABLE       :: tmpDatasetNames(:)
INTEGER,ALLOCATABLE                  :: Elem_IJK_2D(:,:),Elem_IJK_3D(:,:)
INTEGER                              :: nElems2D,nElems3D,iElem,iElem2D
REAL,ALLOCATABLE                     :: RealArray2D(:,:,:,:),RealArray3D(:,:,:,:)
INTEGER                              :: N
INTEGER                              :: p,q,i,j
CHARACTER(LEN=255)                   :: OldFileName,FileName
!===================================================================================================================================
CALL SetStackSizeUnlimited()
CALL InitMPI()
IF (nProcessors.GT.1) CALL CollectiveStop(__STAMP__, &
     'This tool is designed only for single execution!')

CALL ParseCommandlineArguments()
! Check for correct number of input files
IF (nArgs.NE.3) THEN
  CALL CollectiveStop(__STAMP__,'ERROR - Invalid syntax. Please use: posti_to3D 2D_mesh.h5 extruded3D_mesh.h5 fileToExtrude.h5')
END IF

! Read in the ijk sorting of the 2D mesh
CALL OpenDataFile(TRIM(Args(1)),create=.FALSE.,single=.TRUE.,readOnly=.TRUE.)
CALL GetDataSize(File_ID,'Elem_IJK',nDims,HSize)
nElems2D = INT(HSIZE(nDims))
ALLOCATE(Elem_IJK_2D(3,nElems2D))
CALL ReadArray('Elem_IJK',2,(/3,nElems2D/),0,2,IntArray=Elem_IJK_2D)
CALL CloseDataFile()


! Read in the ijk sorting of the 3D mesh
CALL OpenDataFile(TRIM(Args(2)),create=.FALSE.,single=.TRUE.,readOnly=.TRUE.)
CALL GetDataSize(File_ID,'Elem_IJK',nDims,HSize)
nElems3D = INT(HSIZE(nDims))
ALLOCATE(Elem_IJK_3D(3,nElems3D))
CALL ReadArray('Elem_IJK',2,(/3,nElems3D/),0,2,IntArray=Elem_IJK_3D)
CALL CloseDataFile()

! Get the names of the data sets in the file, and information about array size etc.
CALL OpenDataFile(TRIM(Args(3)),create=.FALSE.,single=.TRUE.,readOnly=.TRUE.)
CALL GetDatasetNamesInGroup("/",tmpDatasetNames)
CALL GetDataSize(File_ID,TRIM(tmpDatasetNames(1)),nDims,HSize)
N = INT(HSize(1))-1
ALLOCATE(RealArray2D(0:N,0:N,0:0,nElems2D))
CALL ReadArray(TRIM(tmpDatasetNames(1)),4,(/N+1,N+1,1,nElems2D/),0,4,RealArray=RealArray2D)
CALL CloseDataFile()

! Prepare 3D array
ALLOCATE(RealArray3D(0:N,0:N,0:N,nElems3D))
DO iElem=1,nElems3D
  ! Get the i and j indizes
  i=Elem_IJK_3D(1,iElem)
  j=Elem_IJK_3D(2,iElem)
  ! Search for these indizes in the 2D mesh
  DO iElem2D=1,nElems2D
    IF ((Elem_IJK_2D(1,iElem2D).EQ.i).AND.(Elem_IJK_2D(2,iElem2D).EQ.j)) EXIT
  END DO ! iElem
  ! Extrude the solution in this cell
  DO q=0,N; DO p=0,N
    RealArray3D(p,q,:,iElem) = RealArray2D(p,q,0,iElem2D)
  END DO; END DO ! p,q=0,N
END DO ! iElem

! Open new file and write the array
OldFileName = TRIM(Args(3))
FileName = OldFileName(:LEN(TRIM(OldFileName))-3)//'_extruded.h5'
CALL OpenDataFile(TRIM(FileName),create=.TRUE.,single=.TRUE.,readOnly=.FALSE.)
CALL WriteArray(TRIM(tmpDatasetNames(1)),4,&
                (/N+1,N+1,N+1,nElems3D/),&
                (/N+1,N+1,N+1,nElems3D/),&
                (/0  ,0  ,0  ,0       /),.FALSE.,RealArray=RealArray3D)
CALL CloseDataFile()

SDEALLOCATE(tmpDatasetNames)
SDEALLOCATE(Elem_IJK_2D)
SDEALLOCATE(Elem_IJK_3D)
SDEALLOCATE(RealArray2D)
SDEALLOCATE(RealArray3D)

#if USE_MPI
CALL FinalizeMPI()
CALL MPI_FINALIZE(iError)
IF(iError .NE. 0) STOP 'MPI finalize error'
#endif

WRITE(UNIT_stdOut,'(132("="))')
WRITE(UNIT_stdOut,'(A)') ' TO3D TOOL FINISHED! '
WRITE(UNIT_stdOut,'(132("="))')

END PROGRAM to3D
